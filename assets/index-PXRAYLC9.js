var t=Object.defineProperty,e=(e,i,s)=>((e,i,s)=>i in e?t(e,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[i]=s)(e,"symbol"!=typeof i?i+"":i,s);import{r as i,g as s}from"./phaser-CKN4kaq3.js";!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))e(t);new MutationObserver((t=>{for(const i of t)if("childList"===i.type)for(const t of i.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&e(t)})).observe(document,{childList:!0,subtree:!0})}function e(t){if(t.ep)return;t.ep=!0;const e=function(t){const e={};return t.integrity&&(e.integrity=t.integrity),t.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),"use-credentials"===t.crossOrigin?e.credentials="include":"anonymous"===t.crossOrigin?e.credentials="omit":e.credentials="same-origin",e}(t);fetch(t.href,e)}}();const o=s(i());class h extends o.Scene{constructor(){super({key:"BootScene"})}preload(){this.load.image("background","assets/images/background/background.png"),this.load.atlas("bubbles","assets/images/bubbles/bubbles_spritesheet.png","assets/images/bubbles/bubbles_spritesheet.json")}create(){this.scene.start("GameScene")}}const n=[{label:"orange",color:16081665},{label:"yellow",color:16109829},{label:"cyan",color:63127},{label:"light-blue",color:10150133},{label:"purple",color:9269719},{label:"pink",color:15626403}];function r(){const t=Math.floor(Math.random()*n.length);return{label:n[t].label,color:n[t].color}}var l=(t=>(t[t.BOTTOM_LEFT=0]="BOTTOM_LEFT",t[t.BOTTOM_RIGHT=1]="BOTTOM_RIGHT",t[t.LEFT=2]="LEFT",t[t.RIGHT=3]="RIGHT",t[t.TOP_LEFT=4]="TOP_LEFT",t[t.TOP_RIGHT=5]="TOP_RIGHT",t))(l||{});class b extends o.GameObjects.Sprite{constructor(t,i,s,o,h="static",n="bubbles",r){super(t,i,s,n,r.label),e(this,"_bubbleType"),e(this,"_color"),e(this,"_width"),e(this,"_neighbors"),this._bubbleType=h,this._color=r,this._width=o,this.scene.add.existing(this),this.setBubbleSize(),this.initPhysics()}get color(){return this._color}get bubbleType(){return this._bubbleType}set bubbleType(t){this._bubbleType=t}get neighbors(){return this._neighbors}assignNeighbor(t,e){this._neighbors.set(t,e)}pop(){this.destroy()}fall(){this.body instanceof o.Physics.Arcade.Body&&(this.body.enable=!0,this.body.setVelocityY(200))}shot(t,e=600){const i=t.x-this.x,s=t.y-this.y,o=Math.sqrt(i*i+s*s);if(o>0){const t=i/o,h=s/o;this.body.setVelocity(t*e,h*e)}}checkCollision(t){for(const e of t.getBubbles())if(this.isOverlapping(e))return e;return null}snapTo(t,e){this.scene.tweens.add({targets:this,x:t,y:e,duration:100,ease:"Power2"})}isOverlapping(t){const e=this.x-t.x,i=this.y-t.y;return Math.sqrt(e*e+i*i)<this._width}setBubbleSize(){if(this.width>0){const t=this._width/this.width;this.setScale(t)}else this.once(o.Loader.Events.COMPLETE,(()=>{const t=this._width/this.width;this.setScale(t)}))}initPhysics(){this.scene.physics.add.existing(this),this.body instanceof o.Physics.Arcade.Body&&(this.body.setCollideWorldBounds(!0),this.body.setVelocity(0,0),this.body.setBounce(1,1))}destroy(...t){this._neighbors.clear(),super.destroy(...t)}}class a extends o.GameObjects.Graphics{constructor(t,i){super(t),e(this,"origin"),e(this,"bubble"),e(this,"dashLength",10),e(this,"gapLength",5),e(this,"aimColor"),e(this,"target"),this.bubble=i,this.origin=new o.Math.Vector2(i.x,i.y),this.target=new o.Math.Vector2(0,0),this.aimColor=i.color.color,t.add.existing(this),this.registerInputListeners()}registerInputListeners(){const t=this.scene.input;t.on("pointerdown",this.onPointerDown,this),t.on("pointermove",this.onPointerMove,this),t.on("pointerup",this.onPointerUp,this)}onPointerDown(t){this.updateTarget(t),this.redrawAimingLine(t)}onPointerMove(t){t.isDown&&(this.updateTarget(t),this.redrawAimingLine(t))}onPointerUp(){this.clear(),this.target.equals(this.origin)||this.bubble.shot({x:this.target.x,y:this.target.y})}updateTarget(t){this.target.set(t.x,t.y)}redrawAimingLine(t){this.clear(),this.lineStyle(1,this.aimColor);const e=o.Math.Angle.Between(this.origin.x,this.origin.y,t.x,t.y),i=Math.sqrt(Math.pow(this.scene.scale.width,2)+Math.pow(this.scene.scale.height,2)),s=new o.Math.Vector2(t.x+Math.cos(e)*i,t.y+Math.sin(e)*i);this.drawDashedLine(this.origin,new o.Math.Vector2(t.x,t.y)),this.drawDashedLine(new o.Math.Vector2(t.x,t.y),s)}drawDashedLine(t,e){const i=o.Math.Distance.Between(t.x,t.y,e.x,e.y),s=o.Math.Angle.Between(t.x,t.y,e.x,e.y);let h=i,n=t.clone();for(;h>0;){const t=Math.min(this.dashLength,h),e=new o.Math.Vector2(n.x+Math.cos(s)*t,n.y+Math.sin(s)*t);this.moveTo(n.x,n.y),this.lineTo(e.x,e.y),n.set(e.x+Math.cos(s)*this.gapLength,e.y+Math.sin(s)*this.gapLength),h-=this.dashLength+this.gapLength}this.strokePath()}destroy(...t){const e=this.scene.input;e.off("pointerdown",this.onPointerDown,this),e.off("pointermove",this.onPointerMove,this),e.off("pointerup",this.onPointerUp,this),super.destroy(...t)}}class c{constructor(t,i,s,o,h){e(this,"scene"),e(this,"bubblesGroup"),e(this,"bubbleMap"),e(this,"grid"),e(this,"bubbleWidth"),e(this,"bubbleRadius"),e(this,"rowHeight"),this.scene=t,this.bubbleWidth=h,this.bubbleRadius=this.bubbleWidth/2,this.rowHeight=.866*this.bubbleWidth,this.bubblesGroup=new Phaser.GameObjects.Group(this.scene),this.bubbleMap=new Map,this.grid=Array.from({length:s},(()=>Array(i).fill(null))),this.createGrid(i,s,o),this.assignNeighbors(s)}handleBubbleCollision(t,e){if(e.color.color===t.color.color)return this.removeBubble(e),void this.removeBubble(t);const{x:i,y:s}=this.findNearestPositionForTargetBubble(e);t.body.setVelocity(0,0),t.snapTo(i,s),t.bubbleType="static",this.addBubble(t)}addBubble(t){const e=this.normalize(t.x),i=this.normalize(t.y);this.bubblesGroup.add(t),this.bubbleMap.set(`${e},${i}`,t)}removeBubble(t){const e=this.normalize(t.x),i=this.normalize(t.y);this.bubblesGroup.remove(t,!1,!1),this.bubbleMap.delete(`${e},${i}`),t.destroy()}isPositionEmpty(t,e){const i=this.normalize(t),s=this.normalize(e);return!this.bubbleMap.has(`${i},${s}`)}getBubbles(){return this.bubblesGroup.getChildren()}createGrid(t,e,i){let s=0;for(let o=0;o<e;o++){const e=o%2==0,h=e?this.bubbleRadius:0,n=t-(e?1:0);for(let t=0;t<n;t++){s++;const e=this.normalize(this.bubbleRadius+t*this.bubbleWidth+h),n=this.normalize(this.bubbleRadius+o*this.rowHeight),l=new b(this.scene,e,n,this.bubbleWidth,"static",i,r());console.log(`Bubble ${s} position: ${e}, ${n}`),this.bubblesGroup.add(l),this.bubbleMap.set(`${e},${n}`,l),this.grid[o][t]=l}}}assignNeighbors(t){for(let e=0;e<t;e++)if(this.grid[e])for(let i=0;i<this.grid[e].length;i++){const s=this.grid[e][i];if(!s)continue;const o=e%2==0;i-1>=0?s.assignNeighbor(l.LEFT,this.grid[e][i-1]):s.assignNeighbor(l.LEFT,1),i+1<this.grid[e].length?s.assignNeighbor(l.RIGHT,this.grid[e][i+1]):s.assignNeighbor(l.RIGHT,1);{const t=e-1,h=i+(o?0:-1);t>=0&&h>=0&&this.grid[t]&&h<this.grid[t].length?s.assignNeighbor(l.TOP_LEFT,this.grid[t][h]):s.assignNeighbor(l.TOP_LEFT,1)}{const t=e-1,h=i+(o?1:0);t>=0&&this.grid[t]&&h>=0&&h<this.grid[t].length?s.assignNeighbor(l.TOP_RIGHT,this.grid[t][h]):s.assignNeighbor(l.TOP_RIGHT,1)}{const h=e+1,n=i+(o?0:-1);h<t&&this.grid[h]&&n>=0&&n<this.grid[h].length?s.assignNeighbor(l.BOTTOM_LEFT,this.grid[h][n]):s.assignNeighbor(l.BOTTOM_LEFT,1)}{const h=e+1,n=i+(o?1:0);h<t&&this.grid[h]&&n>=0&&n<this.grid[h].length?s.assignNeighbor(l.BOTTOM_RIGHT,this.grid[h][n]):s.assignNeighbor(l.BOTTOM_RIGHT,1)}}}findNearestPositionForTargetBubble(t){const e=this.getPotentialNeighborPositions(t.x,t.y);for(const{x:i,y:s}of e)if(this.isPositionEmpty(i,s)){const t=this.normalize(i),e=this.normalize(s);return console.log("Nearest empty position found",{x:t,y:e}),{x:t,y:e}}return console.warn("No empty position found, snapping to target bubble"),{x:this.normalize(t.x),y:this.normalize(t.y)}}getPotentialNeighborPositions(t,e){return[{x:t+this.bubbleWidth,y:e},{x:t-this.bubbleWidth,y:e},{x:t+this.bubbleRadius,y:e+this.rowHeight},{x:t-this.bubbleRadius,y:e+this.rowHeight},{x:t+this.bubbleRadius,y:e-this.rowHeight},{x:t-this.bubbleRadius,y:e-this.rowHeight}]}normalize(t,e=2){return parseFloat(t.toFixed(e))}}class u extends Phaser.Scene{constructor(){super({key:"GameScene"}),e(this,"shootingBubble",null),e(this,"aimer",null),e(this,"cols",6),e(this,"rows",2),e(this,"bubbleCluster")}create(){const t=this.scale.width/this.cols;this.add.image(this.scale.width/2,this.scale.height/2,"background"),this.bubbleCluster=new c(this,this.cols,this.rows,"bubbles",t),this.spawnShootingBubble(t)}spawnShootingBubble(t){var e;null==(e=this.aimer)||e.destroy(),this.shootingBubble=new b(this,this.scale.width/2,this.scale.height-100,t,"shooting","bubbles",r()),this.aimer=new a(this,this.shootingBubble)}handleCollision(){var t;const e=null==(t=this.shootingBubble)?void 0:t.checkCollision(this.bubbleCluster);this.shootingBubble&&e&&(this.bubbleCluster.handleBubbleCollision(this.shootingBubble,e),this.spawnShootingBubble(this.scale.width/this.cols))}isBubbleMoving(){var t;return(null==(t=this.shootingBubble)?void 0:t.body).velocity.length()>0}update(){this.isBubbleMoving()&&this.handleCollision()}}const d={type:o.AUTO,width:390,height:844,pixelArt:!1,title:"Purple Land",scene:[h,u],parent:"game-container",scale:{mode:o.Scale.RESIZE,autoCenter:o.Scale.CENTER_BOTH},physics:{default:"arcade",arcade:{gravity:{x:0,y:0},debug:!1}}};window.addEventListener("load",(()=>{new o.Game(d)}));
