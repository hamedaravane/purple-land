var t=Object.defineProperty,e=(e,s,i)=>((e,s,i)=>s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[s]=i)(e,"symbol"!=typeof s?s+"":s,i);import{r as s,g as i}from"./phaser-CKN4kaq3.js";!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))e(t);new MutationObserver((t=>{for(const s of t)if("childList"===s.type)for(const t of s.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&e(t)})).observe(document,{childList:!0,subtree:!0})}function e(t){if(t.ep)return;t.ep=!0;const e=function(t){const e={};return t.integrity&&(e.integrity=t.integrity),t.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),"use-credentials"===t.crossOrigin?e.credentials="include":"anonymous"===t.crossOrigin?e.credentials="omit":e.credentials="same-origin",e}(t);fetch(t.href,e)}}();const o=i(s());class r{constructor(t,s,i,o,r){e(this,"isPointerDown",!1),e(this,"pointerGraphics"),e(this,"colorHex"),this.scene=t,this.shootingBubble=s,this.tapShootUseCase=i,this.bubbleRadius=o,this.shotRadius=r,this.colorHex=16777215,"red"===this.shootingBubble.color&&(this.colorHex=16711680),"green"===this.shootingBubble.color&&(this.colorHex=65280),"blue"===this.shootingBubble.color&&(this.colorHex=255),"yellow"===this.shootingBubble.color&&(this.colorHex=16776960),"purple"===this.shootingBubble.color&&(this.colorHex=16711935)}setup(){this.pointerGraphics=this.scene.add.graphics({x:0,y:0}),this.scene.input.on("pointerdown",(()=>{this.isPointerDown=!0})),this.scene.input.on("pointermove",(t=>{this.isPointerDown&&this.drawDashedLine(this.shootingBubble.position.x,this.shootingBubble.position.y,t.x,t.y)})),this.scene.input.on("pointerup",(t=>{this.isPointerDown=!1,this.pointerGraphics.clear(),this.tapShootUseCase.execute({x:t.x,y:t.y},this.shotRadius,this.bubbleRadius)}))}drawDashedLine(t,e,s,i){this.pointerGraphics.clear(),this.pointerGraphics.lineStyle(2,this.colorHex,1);const o=s-t,r=i-e,n=Math.sqrt(o*o+r*r),l=Math.atan2(r,o);let c=t,h=e;this.pointerGraphics.beginPath();let a=n;for(;a>0;){const t=Math.min(8,a),e=c+Math.cos(l)*t,s=h+Math.sin(l)*t;this.pointerGraphics.moveTo(c,h),this.pointerGraphics.lineTo(e,s),this.pointerGraphics.strokePath(),c=e+5*Math.cos(l),h=s+5*Math.sin(l),a-=13}this.pointerGraphics.closePath()}}class n{constructor(t=[]){e(this,"bubbles",[]),this.bubbles=t}addBubble(t){this.bubbles.push(t),console.log(`Added Bubble ${t.id} to the cluster.`)}removeBubble(t){const e=this.bubbles.findIndex((e=>e.id===t));-1!==e?(this.bubbles.splice(e,1),console.log(`Removed Bubble ${t} from the cluster.`)):console.warn(`Bubble ${t} not found in the cluster.`)}getBubbles(){return this.bubbles}findBubbleByPosition(t){return this.bubbles.find((e=>e.position.x===t.x&&e.position.y===t.y&&!e.isPopped))||null}moveClusterDown(t){this.bubbles.forEach((e=>{const s=e.position.y+t;e.updatePosition({x:e.position.x,y:s})})),console.log(`Moved the cluster down by ${t} units.`)}clearPoppedBubbles(){this.bubbles=this.bubbles.filter((t=>!t.isPopped)),console.log("Cleared popped bubbles from the cluster.")}}class l{detectCollision(t,e,s,i){for(const o of t.getBubbles())if(!o.isPopped&&this.calculateDistance(e,o.position)<=s+i)return console.log(`Collision detected with Bubble ${o.id}.`),o;return null}calculateDistance(t,e){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}}class c{popConnectedBubbles(t,e,s){if(e.isPopped)return[];const i=[e],o=new Set,r=e.color;for(;i.length>0;){const e=i.shift();o.has(e)||(o.add(e),e.color!==r||e.isPopped)||t.getBubbles().filter((t=>!t.isPopped&&t.color===r&&s(e,t))).forEach((t=>{o.has(t)||i.push(t)}))}for(const n of o)n.pop();return Array.from(o)}}class h{constructor(t=0){this.value=t}increment(t){t>0&&(this.value+=t)}decrement(t){t>0&&(this.value=Math.max(0,this.value-t))}reset(){this.value=0}}class a{constructor(t){this.score=t}applyBubblePoppedScoring(t){const e=this.calculateMultiplier(t);this.score.increment(10*e)}applyPenalty(t){this.score.decrement(t)}resetScore(){this.score.reset()}calculateMultiplier(t){return t>=10?5:t>=5?3:t>=2?2:1}}class u{calculateDirection(t,e){const s=e.x-t.x,i=e.y-t.y,o=Math.sqrt(s*s+i*i);return 0===o?(console.warn("Zero-length swipe: defaulting direction to upward."),{x:0,y:-1}):{x:s/o,y:i/o}}calculateSpeed(t,e){const s=e.x-t.x,i=e.y-t.y,o=.6*Math.sqrt(s*s+i*i);return Math.max(200,Math.min(o,1e3))}}class b{constructor(t,e,s,i,o=!0){this.id=t,this.position=e,this.direction=s,this.speed=i,this.isActive=o}updatePosition(t){this.isActive&&(this.position.x+=this.direction.x*this.speed*t,this.position.y+=this.direction.y*this.speed*t,console.log(`Shot ${this.id} moved to (${this.position.x.toFixed(2)}, ${this.position.y.toFixed(2)}).`))}deactivate(){this.isActive&&(this.isActive=!1,console.log(`Shot ${this.id} deactivated.`))}}class p{constructor(t){e(this,"shots",[]),e(this,"shotIdCounter",0),this.trajectoryCalculator=t}fireShot(t,e){const s=this.trajectoryCalculator.calculateDirection(t,e),i=this.trajectoryCalculator.calculateSpeed(t,e),o=new b("shot-"+this.shotIdCounter++,{x:t.x,y:t.y},s,i);return this.shots.push(o),console.log(`Fired Shot ${o.id} with direction (${s.x.toFixed(2)}, ${s.y.toFixed(2)}) and speed ${i.toFixed(2)}.`),o}updateShots(t){this.shots.forEach((e=>{e.isActive&&e.updatePosition(t)})),this.shots=this.shots.filter((t=>t.isActive))}deactivateShot(t){const e=this.shots.find((e=>e.id===t));e&&e.deactivate()}getActiveShots(){return this.shots.filter((t=>t.isActive))}clearAllShots(){this.shots.forEach((t=>t.deactivate())),this.shots=[],console.log("All shots have been cleared.")}}class d{constructor(t,e,s,i=!1){this.id=t,this.color=e,this.position=s,this.isPopped=i}pop(){this.isPopped?console.warn(`Bubble ${this.id} is already popped.`):(this.isPopped=!0,console.log(`Bubble ${this.id} popped!`))}updatePosition(t){this.position=t,console.log(`Bubble ${this.id} moved to (${t.x}, ${t.y}).`)}}class y{constructor(t,e,s,i,o,r,n){this.shootingService=t,this.collisionService=e,this.clusterPopService=s,this.bubbleCluster=i,this.scoringService=o,this.trajectoryCalculator=r,this.shootingBubble=n}execute(t,e,s){const i=this.trajectoryCalculator.calculateDirection(this.shootingBubble.position,t),o=this.shootingService.fireShot(this.shootingBubble.position,{x:this.shootingBubble.position.x+10*i.x,y:this.shootingBubble.position.y+10*i.y});o.direction=i,o.speed=400;const r=this.collisionService.detectCollision(this.bubbleCluster,o.position,e,s);if(r){const t=this.clusterPopService.popConnectedBubbles(this.bubbleCluster,r,(()=>function(t,e){const s=t.x-e.x,i=t.y-e.y;return s*s+i*i<=1024}(o.position,{x:500,y:0})));t.length>0&&this.scoringService.applyBubblePoppedScoring(t.length),this.shootingService.deactivateShot(o.id)}this.shootingBubble.isPopped=!0}}class f{arrange(t,e){const{rows:s,cols:i,bubbleRadius:o,colors:r}=e,n=o*Math.sqrt(3),l=2*o;let c=0;for(let h=0;h<s;h++)for(let e=0;e<i;e++){const s=e*l+o+(h%2==0?0:o)+100,i=h*n+o+50,a=r[c%r.length],u=new d(`hex-bubble-${c}`,a,{x:s,y:i},!1);t.addBubble(u),c++}}}class g extends o.Scene{constructor(){super({key:"MainScene"}),e(this,"tapInputSystem"),e(this,"bubbleGraphics",[]),e(this,"bubbleCluster"),e(this,"score")}create(){this.bubbleCluster=new n,this.score=new h;const t=new l,e=new c,s=new a(this.score),i=new u,o=new p(i);(new f).arrange(this.bubbleCluster,{rows:5,cols:8,bubbleRadius:20,colors:[16711680,255,65280,16776960,16711935]}),this.drawHexBubbles();const b=new d("shooter",16711680,{x:this.scale.width/2,y:550}),g=new y(o,t,e,this.bubbleCluster,s,i,b);this.tapInputSystem=new r(this,b,g,15,10),this.tapInputSystem.setup();const x=this.add.graphics();x.fillStyle(16711680,1),x.fillCircle(b.position.x,b.position.y,15);const v=this.add.text(10,10,`Score: ${this.score.value}`,{fontSize:"16px"});this.time.addEvent({delay:500,loop:!0,callback:()=>{v.setText(`Score: ${this.score.value}`)}})}drawHexBubbles(){this.bubbleGraphics.forEach((t=>t.destroy())),this.bubbleGraphics=[];for(const t of this.bubbleCluster.getBubbles()){const e=this.add.graphics();e.lineStyle(2,t.color,1),e.fillStyle(t.color,.7),e.fillCircle(t.position.x,t.position.y,20),this.bubbleGraphics.push(e)}}}class x extends o.Scene{constructor(){super({key:"BootScene"})}preload(){}create(){this.scene.start("MainScene")}}const v={type:o.AUTO,width:600,height:800,scene:[x,g],parent:"game-container",physics:{default:"arcade",arcade:{gravity:{y:0,x:0}}}};window.addEventListener("load",(()=>{new o.Game(v)}));
