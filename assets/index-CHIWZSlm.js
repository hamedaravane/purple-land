var t=Object.defineProperty,e=(e,s,i)=>((e,s,i)=>s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[s]=i)(e,"symbol"!=typeof s?s+"":s,i);import{r as s,g as i}from"./phaser-CKN4kaq3.js";!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))e(t);new MutationObserver((t=>{for(const s of t)if("childList"===s.type)for(const t of s.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&e(t)})).observe(document,{childList:!0,subtree:!0})}function e(t){if(t.ep)return;t.ep=!0;const e=function(t){const e={};return t.integrity&&(e.integrity=t.integrity),t.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),"use-credentials"===t.crossOrigin?e.credentials="include":"anonymous"===t.crossOrigin?e.credentials="omit":e.credentials="same-origin",e}(t);fetch(t.href,e)}}();const o=i(s());class n{constructor(t,s,i,o,n){e(this,"isPointerDown",!1),e(this,"pointerGraphics"),e(this,"colorHex"),this.scene=t,this.shootingBubble=s,this.tapShootUseCase=i,this.bubbleRadius=o,this.shotRadius=n,this.colorHex=16777215,"red"===this.shootingBubble.color&&(this.colorHex=16711680),"green"===this.shootingBubble.color&&(this.colorHex=65280),"blue"===this.shootingBubble.color&&(this.colorHex=255),"yellow"===this.shootingBubble.color&&(this.colorHex=16776960),"purple"===this.shootingBubble.color&&(this.colorHex=16711935)}setup(){this.pointerGraphics=this.scene.add.graphics({x:0,y:0}),this.scene.input.on("pointerdown",(()=>{this.isPointerDown=!0})),this.scene.input.on("pointermove",(t=>{this.isPointerDown&&this.drawDashedLine(this.shootingBubble.position.x,this.shootingBubble.position.y,t.x,t.y)})),this.scene.input.on("pointerup",(t=>{this.isPointerDown=!1,this.pointerGraphics.clear(),this.tapShootUseCase.execute({x:t.x,y:t.y},this.shotRadius,this.bubbleRadius)}))}drawDashedLine(t,e,s,i){this.pointerGraphics.clear(),this.pointerGraphics.lineStyle(2,this.colorHex,1);const o=s-t,n=i-e,r=Math.sqrt(o*o+n*n),c=Math.atan2(n,o);let l=t,h=e;this.pointerGraphics.beginPath();let a=r;for(;a>0;){const t=Math.min(8,a),e=l+Math.cos(c)*t,s=h+Math.sin(c)*t;this.pointerGraphics.moveTo(l,h),this.pointerGraphics.lineTo(e,s),this.pointerGraphics.strokePath(),l=e+5*Math.cos(c),h=s+5*Math.sin(c),a-=13}this.pointerGraphics.closePath()}}class r{constructor(t=[]){e(this,"bubbles",[]),this.bubbles=t}addBubble(t){this.bubbles.push(t),console.log(`Added Bubble ${t.id} to the cluster.`)}removeBubble(t){const e=this.bubbles.findIndex((e=>e.id===t));-1!==e?(this.bubbles.splice(e,1),console.log(`Removed Bubble ${t} from the cluster.`)):console.warn(`Bubble ${t} not found in the cluster.`)}getBubbles(){return this.bubbles}findBubbleByPosition(t){return this.bubbles.find((e=>e.position.x===t.x&&e.position.y===t.y&&!e.isPopped))||null}moveClusterDown(t){this.bubbles.forEach((e=>{const s=e.position.y+t;e.updatePosition({x:e.position.x,y:s})})),console.log(`Moved the cluster down by ${t} units.`)}clearPoppedBubbles(){this.bubbles=this.bubbles.filter((t=>!t.isPopped)),console.log("Cleared popped bubbles from the cluster.")}}class c{detectCollision(t,e,s,i){for(const o of t.getBubbles())if(!o.isPopped&&this.calculateDistance(e,o.position)<=s+i)return console.log(`Collision detected with Bubble ${o.id}.`),o;return null}calculateDistance(t,e){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}}class l{popConnectedBubbles(t,e,s){if(e.isPopped)return[];const i=[e],o=new Set,n=e.color;for(;i.length>0;){const e=i.shift();o.has(e)||(o.add(e),e.color!==n||e.isPopped)||t.getBubbles().filter((t=>!t.isPopped&&t.color===n&&s(e,t))).forEach((t=>{o.has(t)||i.push(t)}))}for(const r of o)r.pop();return Array.from(o)}}class h{constructor(t=0){this.value=t}increment(t){t>0&&(this.value+=t)}decrement(t){t>0&&(this.value=Math.max(0,this.value-t))}reset(){this.value=0}}class a{constructor(t){this.score=t}applyBubblePoppedScoring(t){const e=this.calculateMultiplier(t);this.score.increment(10*e)}applyPenalty(t){this.score.decrement(t)}resetScore(){this.score.reset()}calculateMultiplier(t){return t>=10?5:t>=5?3:t>=2?2:1}}class u{calculateDirection(t,e){const s=e.x-t.x,i=e.y-t.y,o=Math.sqrt(s*s+i*i);return 0===o?(console.warn("Zero-length swipe: defaulting direction to upward."),{x:0,y:-1}):{x:s/o,y:i/o}}calculateSpeed(t,e){const s=e.x-t.x,i=e.y-t.y,o=.6*Math.sqrt(s*s+i*i);return Math.max(200,Math.min(o,1e3))}}class p{constructor(t,e,s,i,o=!0){this.id=t,this.position=e,this.direction=s,this.speed=i,this.isActive=o}updatePosition(t){this.isActive&&(this.position.x+=this.direction.x*this.speed*t,this.position.y+=this.direction.y*this.speed*t,console.log(`Shot ${this.id} moved to (${this.position.x.toFixed(2)}, ${this.position.y.toFixed(2)}).`))}deactivate(){this.isActive&&(this.isActive=!1,console.log(`Shot ${this.id} deactivated.`))}}class d{constructor(t){e(this,"shots",[]),e(this,"shotIdCounter",0),this.trajectoryCalculator=t}fireShot(t,e){const s=this.trajectoryCalculator.calculateDirection(t,e),i=this.trajectoryCalculator.calculateSpeed(t,e),o=new p("shot-"+this.shotIdCounter++,{x:t.x,y:t.y},s,i);return this.shots.push(o),console.log(`Fired Shot ${o.id} with direction (${s.x.toFixed(2)}, ${s.y.toFixed(2)}) and speed ${i.toFixed(2)}.`),o}updateShots(t){this.shots.forEach((e=>{e.isActive&&e.updatePosition(t)})),this.shots=this.shots.filter((t=>t.isActive))}deactivateShot(t){const e=this.shots.find((e=>e.id===t));e&&e.deactivate()}getActiveShots(){return this.shots.filter((t=>t.isActive))}clearAllShots(){this.shots.forEach((t=>t.deactivate())),this.shots=[],console.log("All shots have been cleared.")}}class b{constructor(t,e,s,i=!1){this.id=t,this.color=e,this.position=s,this.isPopped=i}pop(){this.isPopped?console.warn(`Bubble ${this.id} is already popped.`):(this.isPopped=!0,console.log(`Bubble ${this.id} popped!`))}updatePosition(t){this.position=t,console.log(`Bubble ${this.id} moved to (${t.x}, ${t.y}).`)}}class y{constructor(t,e,s,i,o,n,r){this.shootingService=t,this.collisionService=e,this.clusterPopService=s,this.bubbleCluster=i,this.scoringService=o,this.trajectoryCalculator=n,this.shootingBubble=r}execute(t,e,s){const i=this.trajectoryCalculator.calculateDirection(this.shootingBubble.position,t),o=this.shootingService.fireShot(this.shootingBubble.position,{x:this.shootingBubble.position.x+10*i.x,y:this.shootingBubble.position.y+10*i.y});o.direction=i,o.speed=400;const n=this.collisionService.detectCollision(this.bubbleCluster,o.position,e,s);if(n){const t=this.clusterPopService.popConnectedBubbles(this.bubbleCluster,n,(()=>function(t,e){const s=t.x-e.x,i=t.y-e.y;return s*s+i*i<=1024}(o.position,{x:500,y:0})));t.length>0&&this.scoringService.applyBubblePoppedScoring(t.length),this.shootingService.deactivateShot(o.id)}this.shootingBubble.isPopped=!0}}class g extends o.Scene{constructor(){super({key:"MainScene"}),e(this,"tapInputSystem")}create(){const t=new r,e=new c,s=new l,i=new h,o=new a(i),p=new u,g=new d(p),x=new b("shooter","red",{x:400,y:550}),f=new y(g,e,s,t,o,p,x);this.tapInputSystem=new n(this,x,f,15,10),this.tapInputSystem.setup();const v=this.add.graphics();v.fillStyle(16711680,1),v.fillCircle(x.position.x,x.position.y,15);const S=this.add.text(10,10,`Score: ${i.value}`,{fontSize:"16px"});this.time.addEvent({delay:500,loop:!0,callback:()=>{S.setText(`Score: ${i.value}`)}})}}class x extends o.Scene{constructor(){super({key:"BootScene"})}preload(){}create(){this.scene.start("MainScene")}}const f={type:o.AUTO,width:600,height:800,scene:[x,g],parent:"game-container",physics:{default:"arcade",arcade:{gravity:{y:0,x:0}}}};window.addEventListener("load",(()=>{new o.Game(f)}));
